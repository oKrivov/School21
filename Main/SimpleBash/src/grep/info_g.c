#include <getopt.h>  // Подключаем библиотеку для обработки аргументов командной строки
#include <regex.h>  // Подключаем библиотеку для работы с регулярными выражениями
#include <stdio.h>  // Подключаем стандартную библиотеку ввода-вывода
#include <stdlib.h>  // Подключаем стандартную библиотеку для работы с памятью и конвертацией
#include <string.h>  // Подключаем библиотеку для работы со строками

// Определяем структуру для хранения аргументов командной строки
typedef struct arguments {
  int e, i, v, c, l, n, h, s, f, o;  // Флаги для различных опций
  char pattern[1024];  // Массив для хранения регулярного выражения
  int len_pattern;     // Длина текущего регулярного выражения
} arguments;

// Прототипы функций
void pattern_add(arguments *arg, char *pattern);
arguments argumets_parrser(int argc, char *argv[]);
void output_line(char *line, int n);
void process_file(arguments arg, char *path, regex_t *reg);
void output(arguments arg, int argc, char *argv[]);

int main(int argc, char *argv[]) {
  // Парсим аргументы командной строки и сохраняем их в структуре arg
  arguments arg = argumets_parrser(argc, argv);
  // Выводим результаты на основе аргументов и файлов
  output(arg, argc, argv);
  return 0;  // Завершаем программу с кодом 0 (успех)
}

// Функция для добавления нового шаблона к существующему шаблону
void pattern_add(arguments *arg, char *pattern) {
  // Если уже есть шаблон, добавляем разделитель "|"
  if (arg->len_pattern != 0) {
    strcat(arg->pattern + arg->len_pattern, "|");  // Добавляем разделитель
    arg->len_pattern++;                            // Увеличиваем длину шаблона
  }
  // Добавляем новый шаблон в конец существующего
  arg->len_pattern += sprintf(arg->pattern + arg->len_pattern, "(%s)", pattern);
}

// Функция для парсинга аргументов командной строки
arguments argumets_parrser(int argc, char *argv[]) {
  arguments arg = {0};  // Инициализируем структуру аргументов нулями
  int opt;              // Переменная для хранения текущего символа опции
  while ((opt = getopt(argc, argv, "e:ivclnhsf:o")) !=
         -1) {  // Обрабатываем опции
    switch (opt) {
      case 'e':                     // Если указана опция -e
        arg.e = 1;                  // Устанавливаем флаг e
        pattern_add(&arg, optarg);  // Добавляем паттерн из аргумента
        break;
      case 'i':  // Если указана опция -i
        arg.i =
            REG_ICASE;  // Устанавливаем флаг для нечувствительности к регистру
        break;
      case 'v':     // Если указана опция -v
        arg.v = 1;  // Устанавливаем флаг v (инвертировать результат)
        break;
      case 'c':     // Если указана опция -c
        arg.c = 1;  // Устанавливаем флаг c (вывод количества совпадений)
        break;
      case 'l':     // Если указана опция -l
        arg.l = 1;  // Устанавливаем флаг l (выводим только имена файлов)
        break;
      case 'n':     // Если указана опция -n
        arg.n = 1;  // Устанавливаем флаг n (выводим номера строк)
        break;
      case 'h':     // Если указана опция -h
        arg.h = 1;  // Устанавливаем флаг h (не выводим заголовки)
        break;
      case 's':     // Если указана опция -s
        arg.s = 1;  // Устанавливаем флаг s (игнорировать ошибки)
        break;
      case 'f':     // Если указана опция -f
        arg.f = 1;  // Устанавливаем флаг f (использовать файл с паттернами)
        break;
      case 'o':     // Если указана опция -o
        arg.o = 1;  // Устанавливаем флаг o (выводим совпадения)
        break;
    }
  }

  // Если паттерн не был указан, берем его из оставшихся аргументов
  if (arg.len_pattern == 0) {
    pattern_add(&arg,
                argv[optind]);  // Добавляем паттерн из оставшихся аргументов
    optind++;                   // Переходим к следующему аргументу
  }

  // Если остался только один аргумент, устанавливаем флаг h
  if (argc - optind == 1) arg.h = 1;

  return arg;  // Возвращаем заполненную структуру аргументов
}

// Функция для вывода строки с учетом ее длины
void output_line(char *line, int n) {
  for (int i = 0; i < n; i++) {  // Проходим по каждому символу строки
    putchar(line[i]);            // Выводим символ на экран
  }

  // Если последним символом не является перевод строки, добавляем его
  if (line[n - 1] != '\n') putchar('\n');
}

// Функция для обработки файла с заданными аргументами и регулярным выражением
void process_file(arguments arg, char *path, regex_t *reg) {
  FILE *f = fopen(path, "r");  // Открываем файл для чтения
  if (f == NULL) {             // Проверяем на ошибки открытия файла
    if (!arg.s)
      perror(path);  // Если не игнорируем ошибки, выводим сообщение об ошибке
    exit(1);         // Завершаем программу с кодом ошибки
  }

  char *line = NULL;   // Указатель на строку для чтения из файла
  size_t linecap = 0;  // Размер выделенной памяти для строки
  int read = 0;  // Переменная для хранения количества прочитанных символов
  int line_count = 1;  // Счетчик строк в файле
  int c = 0;           // Счетчик совпадений

  read = getline(&line, &linecap, f);  // Читаем первую строку из файла

  while (read != -1) {  // Пока не достигнут конец файла
    int result = regexec(reg, line, 0, NULL,
                         0);  // Проверяем совпадение с регулярным выражением

    // Проверяем условие вывода: совпадение найдено или инвертировано
    if ((result == 0 && !arg.v) || (result != 0 && arg.v)) {
      if (!arg.c &&
          !arg.l) {  // Если не нужно выводить количество или имена файлов
        if (arg.n)
          printf("%d:",
                 line_count);     // Выводим номер строки если установлен флаг n
        output_line(line, read);  // Выводим строку на экран
      }
      c++;  // Увеличиваем счетчик совпадений
    }

    read = getline(&line, &linecap, f);  // Читаем следующую строку из файла
    line_count++;                        // Увеличиваем счетчик строк
  }

  free(line);  // Освобождаем память под строку

  if (arg.c && !arg.l) {  // Если установлен флаг c и не установлен флаг l
    if (!arg.h)
      printf("%s:", path);  // Выводим имя файла если не установлен флаг h
    printf("%d\n", c);      // Выводим количество совпадений
  }

  if (arg.l && c > 0)
    printf(
        "%s\n",
        path);  // Если установлен флаг l и есть совпадения, выводим имя файла

  fclose(f);  // Закрываем файл после обработки
}

// Функция для вывода результатов по всем файлам на основе аргументов и
// регулярного выражения
void output(arguments arg, int argc, char *argv[]) {
  regex_t
      reg;  // Переменная для хранения скомпилированного регулярного выражения

  int error =
      regcomp(&reg, arg.pattern,
              REG_EXTENDED |
                  arg.i);  // Компилируем регулярное выражение с учетом флага i
  if (error) perror("ERROR");  // Проверяем на ошибки компиляции

  for (int i = optind; i < argc;
       i++) {  // Проходим по всем оставшимся аргументам (файлам)
    process_file(arg, argv[i], &reg);  // Обрабатываем каждый файл с заданными
                                       // аргументами и регулярным выражением
  }

  regfree(&reg);  // Освобождаем ресурсы, выделенные под регулярное выражение
}
