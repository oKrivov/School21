#include <getopt.h>  // Подключаем библиотеку для обработки аргументов командной строки
#include <stdio.h>  // Подключаем библиотеку для работы с вводом-выводом
#include <stdlib.h>  // Подключаем библиотеку для работы с памятью и другими стандартными функциями

// Определяем структуру для хранения аргументов командной строки
typedef struct arguments {
  int b, n, s, E, T, v;  // Переменные для хранения значений флагов
} arguments;

// Функция для парсинга аргументов командной строки
arguments argument_parser(int argc, char* argv[]) {
  arguments arg = {0};  // Инициализируем структуру значениями по умолчанию (0)

  // Определяем длинные опции командной строки
  struct option long_options[] = {
      {"number", 0, 0, 'n'},           // Длинная опция --number
      {"number-nonblank", 0, 0, 'b'},  // Длинная опция --number-nonblank
      {"squeeze-blank", 0, 0, 's'},    // Длинная опция --squeeze-blank
      {0, 0, 0, 0}                     // Завершающий элемент массива
  };

  int opt;  // Переменная для хранения текущего символа опции
  // Цикл для обработки аргументов командной строки
  while ((opt = getopt_long(argc, argv, "bnseEtTv", long_options, 0)) != -1) {
    switch (opt) {  // Обработка каждого флага
      case 'b':
        arg.b = 1;  // Устанавливаем флаг b
        break;
      case 'n':
        arg.n = 1;  // Устанавливаем флаг n
        break;
      case 's':
        arg.s = 1;  // Устанавливаем флаг s
        break;
      case 'e':
        arg.E = 1;  // Устанавливаем флаг E
        arg.v = 1;  // Устанавливаем флаг v
        break;
      case 'E':
        arg.E = 1;  // Устанавливаем флаг E
        break;
      case 't':
        arg.T = 1;  // Устанавливаем флаг T
        arg.v = 1;  // Устанавливаем флаг v
        break;
      case 'T':
        arg.T = 1;  // Устанавливаем флаг T
        break;
      case 'v':
        arg.v = 1;  // Устанавливаем флаг v
        break;
      case '?':           // Если произошла ошибка при парсинге
        perror("Error");  // Выводим сообщение об ошибке
        exit(1);          // Завершаем программу с ошибкой
        break;
      default:
        break;  // Игнорируем другие случаи
    }
  }
  return arg;  // Возвращаем структуру с аргументами
}

// Функция для обработки вывода специальных символов
char v_output(char ch) {
  if (ch == '\n' || ch == '\t')
    return ch;  // Если символ - перевод строки или табуляция, возвращаем его
                // как есть

  if (ch <= 31) {  // Если символ - управляющий (код меньше или равен 31)
    putchar('^');  // Выводим символ '^'
    ch += 64;  // Преобразуем символ в соответствующий вид (например, для ASCII)
  } else if (ch == 127) {  // Если символ - DEL
    putchar('^');
    ch = '?';  // Заменяем на '?'
  }
  return ch;  // Возвращаем обработанный символ
}

// Функция для вывода строки с учетом аргументов
void outline(arguments* arg, char* line, int n) {
  for (int i = 0; i < n; i++) {  // Проходим по каждому символу строки
    if (arg->T && line[i] == '\t')
      printf("^I");  // Если установлен флаг T и символ - табуляция, выводим ^I
    else {
      if (arg->E && line[i] == '\n')
        putchar('$');  // Если установлен флаг E и символ - перевод строки,
                       // выводим $
      if (arg->v)
        line[i] = v_output(line[i]);  // Если установлен флаг v, обрабатываем
                                      // символ через v_output
      putchar(line[i]);               // Выводим текущий символ
    }
  }
}

// Функция для чтения и обработки файла
void output(arguments* arg, char* argv[]) {
  FILE* f = fopen(
      argv[optind],
      "r");  // Открываем файл на чтение по индексу аргумента командной строки
  if (!f) {  // Проверка успешного открытия файла
    perror("Error opening file");  // Сообщаем об ошибке открытия файла
    exit(1);                       // Завершаем программу с ошибкой
  }

  char* line = NULL;  // Указатель на строку для хранения прочитанной строки
  size_t memline =
      0;         // Переменная для хранения размера выделенной памяти для строки
  int read = 0;  // Переменная для хранения количества прочитанных символов
  int line_count = 1;   // Счетчик строк (начинаем с 1)
  int empty_count = 0;  // Счетчик пустых строк

  while ((read = getline(&line, &memline, f)) != -1) {  // Читаем файл построчно
    if (line[0] == '\n')
      empty_count++;  // Если строка пустая, увеличиваем счетчик пустых строк
    else
      empty_count = 0;  // Если строка не пустая, сбрасываем счетчик

    if (arg->s && empty_count > 1) {
      continue;  // Если установлен флаг s и пустых строк больше одной,
                 // пропускаем текущую итерацию
    } else {
      if (arg->n || arg->b) {  // Если установлен хотя бы один из флагов n или b
        if (arg->b && line[0] != '\n')
          printf("%6d\t", line_count++);  // Если установлен флаг b и строка не
                                          // пустая, выводим номер строки
        if (arg->b && arg->E && line[0] == '\n')
          printf("      \t");  // Если установлен флаг b и E для пустой строки,
                               // выводим пробелы и табуляцию
        if (arg->n && !arg->b)
          printf("%6d\t", line_count++);  // Если установлен только флаг n,
                                          // выводим номер строки
      }
      outline(arg, line,
              read);  // Вызываем функцию для вывода строки с учетом аргументов
    }
  }

  free(line);  // Освобождаем память, выделенную под строку
  fclose(f);   // Закрываем файл
}

// Главная функция программы
int main(int argc, char* argv[]) {
  arguments arg =
      argument_parser(argc, argv);  // Парсим аргументы командной строки

  if (optind >=
      argc) {  // Проверка на наличие дополнительных аргументов после опций
    fprintf(
        stderr,
        "Expected argument after options\n");  // Выводим сообщение об ошибке
    return EXIT_FAILURE;                       // Завершаем программу с ошибкой
  }

  output(&arg, argv);  // Вызываем функцию для обработки файла и вывода

  return 0;  // Завершаем программу успешно
}